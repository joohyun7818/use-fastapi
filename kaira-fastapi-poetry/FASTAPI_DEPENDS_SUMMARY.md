# FastAPI `Depends()` 메서드 요약

FastAPI의 `Depends()`는 의존성 주입(Dependency Injection) 시스템의 핵심적인 부분으로, 경로 작동 함수(route)가 필요로 하는 전제 조건이나 공유 서비스를 선언하고 관리하는 데 사용됩니다. 이는 단순한 함수 호출을 넘어, FastAPI 프레임워크가 제공하는 여러 강력한 기능들을 활용하게 합니다.

## `Depends()`를 사용하는 주된 이유

1.  **코드 재사용성**: 데이터베이스 세션, 사용자 인증 정보 등 공통 로직을 별도의 함수로 분리하여 여러 경로에서 재사용할 수 있습니다.
2.  **계층 분리 (Separation of Concerns)**: 비즈니스 로직과 의존성 관리를 분리하여 코드를 더 깔끔하고 테스트하기 쉽게 만듭니다.
3.  **자동 문서화**: `Depends()`로 선언된 의존성은 FastAPI의 자동 생성 문서(Swagger UI, ReDoc)에 반영되어 API의 요구사항을 명확하게 보여줍니다.
4.  **테스트 용이성**: 의존성을 쉽게 모의(mock)할 수 있어 단위 테스트 작성이 용이합니다.

## `Depends()`가 제공하는 특별한 기능

`Depends()`로 함수를 감싸는 것은 FastAPI에게 해당 함수를 특별하게 처리하도록 지시하는 것입니다.

1.  **요청마다 새로운 실행 (Request-Scoped Execution)**:
    *   `Depends()`로 감싸진 함수는 해당 경로로 **요청이 들어올 때마다 매번 새로 호출**됩니다. 이를 통해 각 요청은 독립적인 데이터베이스 세션, 사용자 정보 등을 가질 수 있습니다. (일반 함수 호출과의 가장 큰 차이점)
2.  **의존성의 의존성 해결 (Dependency Hierarchy)**:
    *   `Depends()`로 지정된 함수가 또 다른 `Depends()` 의존성을 가질 수 있습니다. FastAPI는 이 의존성 계층을 파악하고, 가장 하위 의존성부터 순서대로 실행하여 그 결과를 상위 의존성에 주입합니다.
3.  **자원 관리 (Setup & Teardown)**:
    *   의존성 함수에서 `yield`를 사용하면, 요청이 처리되기 전에 실행될 코드(setup)와 요청이 끝난 후에 실행될 코드(teardown)를 정의할 수 있습니다. 이는 데이터베이스 세션 열기/닫기와 같은 자원 해제 로직을 안전하게 처리하는 데 필수적입니다.
    ```python
    def get_db():
        db = SessionLocal()
        try:
            yield db  # 요청 처리 중에는 이 db 세션을 사용
        finally:
            db.close() # 요청이 끝나면 세션을 자동으로 닫음
    ```
4.  **자동 형 변환 및 유효성 검사**:
    *   의존성 함수가 받는 매개변수(쿼리 파라미터, 헤더 등)에 대해 FastAPI는 자동으로 데이터 타입을 변환하고 Pydantic 모델을 통해 유효성을 검사합니다.
5.  **자동 문서화 연동**:
    *   FastAPI는 `Depends()`를 분석하여 API 문서에 해당 의존성이 요구하는 파라미터(예: `Authorization` 헤더)를 자동으로 추가합니다.

## `Depends()` 사용 규칙: 언제 사용해야 하는가?

핵심 원칙은 **"경로 작동 함수가 자신의 핵심 비즈니스 로직을 수행하기 위해 '필요로 하는 전제 조건'이나 '공유 서비스'는 `Depends()`로 분리한다"**는 것입니다. 이는 주로 **횡단 관심사(Cross-Cutting Concerns)**에 해당합니다.

1.  **자원 관리 (Resource Management)**:
    *   **대상**: 데이터베이스 세션/커넥션, 외부 API 클라이언트, 파일 핸들 등.
    *   **예시**: `db: Session = Depends(get_db)`
2.  **인증 및 권한 부여 (Authentication & Authorization)**:
    *   **대상**: 토큰 검증, 현재 로그인된 사용자 객체 반환, 특정 권한 확인 로직.
    *   **예시**: `current_user: User = Depends(get_current_active_user)`
3.  **공유되는 복잡한 매개변수 처리**:
    *   **대상**: 여러 엔드포인트에서 공통적으로 사용되는 쿼리 파라미터 그룹(예: 페이지네이션, 정렬, 필터링).
    *   **예시**: `pagination_params: dict = Depends(common_parameters)`
4.  **설정 및 구성 주입 (Configuration Injection)**:
    *   **대상**: 애플리케이션의 설정 값(환경 변수 등)을 제공하는 함수.
    *   **예시**: `settings: Settings = Depends(get_settings)`

### 간단한 체크리스트

어떤 함수를 `Depends()`로 감싸야 할지 고민될 때 다음 질문을 해보세요.

*   이 기능이 다른 엔드포인트에서도 필요한가? (재사용성)
*   요청이 시작될 때 준비(setup)하고 끝날 때 정리(teardown)해야 하는 작업인가? (자원 관리)
*   사용자 인증이나 특정 권한 확인과 관련이 있는가? (보안)
*   FastAPI의 요청(Request) 객체나 다른 의존성의 결과가 필요한가? (컨텍스트)

위 질문 중 하나라도 **"예"**라고 답할 수 있다면, 해당 기능은 `Depends()`를 사용할 좋은 후보입니다.

## `Depends()`로 감싸지 **않아야** 하는 것들

1.  **해당 엔드포인트의 핵심 비즈니스 로직**: 엔드포인트 고유의 작업은 함수 내에 직접 구현하거나 일반 유틸리티 함수로 호출합니다.
2.  **간단한 데이터 변환 또는 유효성 검사**: FastAPI는 Pydantic 모델과 타입 힌트를 통해 대부분을 자동으로 처리합니다.
3.  **요청 컨텍스트와 무관한 일반 유틸리티 함수**: 요청 객체나 다른 의존성과 상호작용하지 않는 순수한 함수는 `Depends()` 없이 직접 호출합니다.
